---
title: "Integration Patterns"
description: "Common integration patterns, best practices, and architectural guidance for Request Network implementations"
---

## Overview

This guide covers proven integration patterns, architectural best practices, and common implementation approaches for Request Network. Whether you're building a simple invoicing system or a complex multi-tenant platform, these patterns will help you implement robust, scalable payment infrastructure.

## Common Integration Architectures

### Server-Side Integration Pattern
Recommended for production applications requiring security and control.

<Tabs>
  <Tab title="Architecture">
    **Server-Side Flow:**
    ```
    Frontend → Backend API → Request Network → Blockchain
         ↓
    Webhook Handler ← Request Network ← Payment Confirmation
         ↓
    Business Logic → Database → Frontend Updates
    ```
    
    **Benefits:**
    - Secure API key management
    - Centralized business logic
    - Reliable webhook handling
    - Scalable architecture
  </Tab>
  
  <Tab title="Implementation">
    ```javascript
    // Backend API endpoint
    app.post('/api/create-invoice', async (req, res) => {
      try {
        // Validate request
        const { amount, currency, customerEmail } = req.body;
        
        // Create Request Network payment request
        const paymentRequest = await requestNetwork.createRequest({
          requestInfo: {
            currency,
            expectedAmount: amount,
            payee: { type: 'ethereumAddress', value: merchantAddress },
            payer: { type: 'ethereumAddress', value: customerAddress }
          },
          contentData: {
            reason: 'Invoice Payment',
            customerEmail,
            invoiceId: generateInvoiceId()
          }
        });
        
        // Store in database
        await db.invoices.create({
          requestId: paymentRequest.requestId,
          amount,
          currency,
          customerEmail,
          status: 'pending'
        });
        
        res.json({ 
          requestId: paymentRequest.requestId,
          paymentUrl: `${baseUrl}/pay/${paymentRequest.requestId}`
        });
        
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });
    ```
  </Tab>
  
  <Tab title="Security">
    **Security Best Practices:**
    - API keys stored in environment variables
    - Request validation and sanitization
    - Rate limiting on API endpoints
    - CORS configuration
    - Webhook signature verification
    
    ```javascript
    // Environment configuration
    const config = {
      requestNetwork: {
        apiKey: process.env.REQUEST_NETWORK_API_KEY,
        webhookSecret: process.env.REQUEST_WEBHOOK_SECRET,
        environment: process.env.NODE_ENV === 'production' ? 'mainnet' : 'testnet'
      }
    };
    
    // Middleware for API key validation
    const validateApiKey = (req, res, next) => {
      const apiKey = req.headers['x-api-key'];
      if (!apiKey || !isValidApiKey(apiKey)) {
        return res.status(401).json({ error: 'Invalid API key' });
      }
      next();
    };
    ```
  </Tab>
</Tabs>

### Client-Side Integration Pattern
Suitable for simple applications and rapid prototyping.

<Tabs>
  <Tab title="Architecture">
    **Client-Side Flow:**
    ```
    Frontend App → Request Network SDK → Blockchain
         ↓
    Payment Widget → Wallet Connection → Transaction
         ↓
    Confirmation → Frontend Updates → Backend Sync
    ```
    
    **Benefits:**
    - Faster development
    - Reduced backend complexity
    - Real-time user feedback
    - Lower infrastructure costs
  </Tab>
  
  <Tab title="Implementation">
    ```javascript
    // Frontend payment component
    import { RequestNetwork } from '@requestnetwork/request-client.js';
    
    function PaymentComponent({ invoiceData }) {
      const [paymentStatus, setPaymentStatus] = useState('pending');
      
      const handlePayment = async () => {
        try {
          setPaymentStatus('processing');
          
          // Create payment request
          const request = await requestNetwork.createRequest({
            requestInfo: {
              currency: invoiceData.currency,
              expectedAmount: invoiceData.amount,
              payee: { type: 'ethereumAddress', value: merchantAddress }
            }
          });
          
          // Process payment
          const payment = await request.pay();
          
          setPaymentStatus('completed');
          onPaymentSuccess(payment);
          
        } catch (error) {
          setPaymentStatus('failed');
          onPaymentError(error);
        }
      };
      
      return (
        <PaymentWidget
          amount={invoiceData.amount}
          currency={invoiceData.currency}
          onPay={handlePayment}
          status={paymentStatus}
        />
      );
    }
    ```
  </Tab>
  
  <Tab title="Limitations">
    **Consider These Limitations:**
    - API keys exposed to frontend
    - Limited server-side validation
    - Webhook handling requires backend
    - Less suitable for production systems
    
    **When to Use:**
    - Prototyping and demos
    - Simple payment collection
    - Low-volume applications
    - Educational purposes
  </Tab>
</Tabs>

## E-commerce Integration Patterns

### Shopify Integration
Connect Request Network with Shopify for crypto payment acceptance.

<AccordionGroup>
  <Accordion title="Shopify App Architecture">
    **Integration Components:**
    - Shopify App with payment gateway registration
    - Backend service for Request Network integration
    - Webhook handlers for payment confirmation
    - Admin dashboard for configuration
    
    **Flow:**
    1. Customer selects crypto payment at checkout
    2. Shopify redirects to Request Network payment page
    3. Customer completes crypto payment
    4. Webhook confirms payment to Shopify
    5. Order status updated automatically
  </Accordion>
  
  <Accordion title="Implementation Example">
    ```javascript
    // Shopify payment gateway endpoint
    app.post('/shopify/payment/create', async (req, res) => {
      const { order, return_url, cancel_url } = req.body;
      
      // Create Request Network payment request
      const paymentRequest = await requestNetwork.createRequest({
        requestInfo: {
          currency: 'USD',
          expectedAmount: order.total_price,
          payee: { type: 'ethereumAddress', value: merchantAddress }
        },
        contentData: {
          reason: `Shopify Order #${order.order_number}`,
          shopifyOrderId: order.id,
          returnUrl: return_url,
          cancelUrl: cancel_url
        }
      });
      
      // Redirect to payment page
      res.redirect(`/pay/${paymentRequest.requestId}`);
    });
    
    // Payment confirmation webhook
    app.post('/webhook/payment-confirmed', async (req, res) => {
      const { requestId, paymentHash } = req.body;
      
      // Get order info from Request Network
      const request = await requestNetwork.getRequest(requestId);
      const shopifyOrderId = request.contentData.shopifyOrderId;
      
      // Update Shopify order status
      await shopifyAPI.orders.update(shopifyOrderId, {
        financial_status: 'paid',
        transactions: [{
          kind: 'sale',
          status: 'success',
          amount: request.expectedAmount,
          gateway: 'request-network'
        }]
      });
      
      res.status(200).send('OK');
    });
    ```
  </Accordion>
</AccordionGroup>

### WooCommerce Integration
Enable crypto payments in WordPress/WooCommerce stores.

<AccordionGroup>
  <Accordion title="Plugin Architecture">
    **WordPress Plugin Structure:**
    - Payment gateway plugin registration
    - Admin settings page for configuration
    - Checkout integration hooks
    - Order status management
    
    **Key Features:**
    - Seamless checkout experience
    - Automatic order fulfillment
    - Refund handling
    - Multi-currency support
  </Accordion>
  
  <Accordion title="PHP Implementation">
    ```php
    <?php
    // WooCommerce payment gateway class
    class WC_Request_Network_Gateway extends WC_Payment_Gateway {
        
        public function __construct() {
            $this->id = 'request_network';
            $this->method_title = 'Request Network';
            $this->method_description = 'Accept crypto payments via Request Network';
            
            $this->init_form_fields();
            $this->init_settings();
            
            // Hook into WooCommerce
            add_action('woocommerce_update_options_payment_gateways_' . $this->id, 
                      array($this, 'process_admin_options'));
            add_action('woocommerce_api_request_network_webhook', 
                      array($this, 'handle_webhook'));
        }
        
        public function process_payment($order_id) {
            $order = wc_get_order($order_id);
            
            // Create Request Network payment request
            $response = wp_remote_post($this->api_endpoint . '/create-request', array(
                'body' => json_encode(array(
                    'amount' => $order->get_total(),
                    'currency' => $order->get_currency(),
                    'order_id' => $order_id,
                    'return_url' => $this->get_return_url($order)
                )),
                'headers' => array(
                    'Content-Type' => 'application/json',
                    'Authorization' => 'Bearer ' . $this->api_key
                )
            ));
            
            $payment_data = json_decode(wp_remote_retrieve_body($response), true);
            
            // Redirect to payment page
            return array(
                'result' => 'success',
                'redirect' => $payment_data['payment_url']
            );
        }
    }
    ```
  </Accordion>
</AccordionGroup>

## SaaS & Subscription Patterns

### Multi-Tenant SaaS Architecture
Scale Request Network for multiple customers in a SaaS platform.

<Tabs>
  <Tab title="Tenant Isolation">
    **Isolation Strategy:**
    - Separate API keys per tenant
    - Namespace separation for requests
    - Isolated webhook endpoints
    - Tenant-specific fee structures
    
    ```javascript
    // Tenant-aware request creation
    async function createTenantRequest(tenantId, requestData) {
      const tenantConfig = await getTenantConfig(tenantId);
      
      const request = await requestNetwork.createRequest({
        ...requestData,
        contentData: {
          ...requestData.contentData,
          tenantId,
          tenantDomain: tenantConfig.domain
        },
        paymentNetwork: {
          id: 'erc20-fee-proxy-contract',
          parameters: {
            paymentAddress: tenantConfig.walletAddress,
            feeAddress: platformFeeAddress,
            feeAmount: tenantConfig.platformFeePercentage
          }
        }
      }, {
        apiKey: tenantConfig.requestNetworkApiKey
      });
      
      return request;
    }
    ```
  </Tab>
  
  <Tab title="Webhook Routing">
    **Multi-Tenant Webhook Handling:**
    - Single webhook endpoint for all tenants
    - Route events based on tenant identification
    - Isolated processing per tenant
    - Failover and retry mechanisms
    
    ```javascript
    app.post('/webhook/payment-events', async (req, res) => {
      try {
        const { eventType, data } = req.body;
        const tenantId = data.contentData?.tenantId;
        
        if (!tenantId) {
          return res.status(400).send('Missing tenant ID');
        }
        
        // Route to tenant-specific handler
        const tenantHandler = getTenantHandler(tenantId);
        await tenantHandler.processEvent(eventType, data);
        
        res.status(200).send('OK');
        
      } catch (error) {
        console.error('Webhook error:', error);
        res.status(500).send('Error processing webhook');
      }
    });
    ```
  </Tab>
  
  <Tab title="Billing Integration">
    **SaaS Billing Patterns:**
    - Usage-based billing with Request Network
    - Platform fees from tenant transactions
    - Automated billing for SaaS subscriptions
    - Revenue sharing with tenants
    
    ```javascript
    // Calculate and charge platform fees
    async function processPlatformBilling(tenantId, billingPeriod) {
      const usage = await getUsageMetrics(tenantId, billingPeriod);
      const tenantConfig = await getTenantConfig(tenantId);
      
      const platformFee = calculatePlatformFee(usage, tenantConfig.pricingTier);
      
      // Create platform billing request
      const billingRequest = await requestNetwork.createRequest({
        requestInfo: {
          currency: 'USD',
          expectedAmount: platformFee.toString(),
          payee: { type: 'ethereumAddress', value: platformWalletAddress },
          payer: { type: 'ethereumAddress', value: tenantConfig.walletAddress }
        },
        contentData: {
          reason: `Platform Fee - ${billingPeriod}`,
          tenantId,
          usageMetrics: usage,
          feeBreakdown: platformFee.breakdown
        }
      });
      
      return billingRequest;
    }
    ```
  </Tab>
</Tabs>

## Enterprise Integration Patterns

### ERP System Integration
Connect Request Network with enterprise resource planning systems.

<AccordionGroup>
  <Accordion title="SAP Integration">
    **SAP S/4HANA Integration:**
    - Invoice creation from SAP sales orders
    - Payment status synchronization
    - Automatic accounting document creation
    - Multi-company and multi-currency support
    
    ```javascript
    // SAP integration service
    class SAPRequestNetworkIntegration {
      async createInvoiceFromSalesOrder(salesOrderId) {
        // Fetch sales order from SAP
        const salesOrder = await this.sapAPI.getSalesOrder(salesOrderId);
        
        // Create Request Network payment request
        const paymentRequest = await requestNetwork.createRequest({
          requestInfo: {
            currency: salesOrder.currency,
            expectedAmount: salesOrder.totalAmount,
            payee: { type: 'ethereumAddress', value: companyWalletAddress }
          },
          contentData: {
            reason: `Invoice for Sales Order ${salesOrderId}`,
            sapSalesOrderId: salesOrderId,
            sapCustomerId: salesOrder.customerId,
            sapCompanyCode: salesOrder.companyCode
          }
        });
        
        // Update SAP with Request Network details
        await this.sapAPI.updateSalesOrder(salesOrderId, {
          paymentRequestId: paymentRequest.requestId,
          paymentStatus: 'pending'
        });
        
        return paymentRequest;
      }
    }
    ```
  </Accordion>
  
  <Accordion title="Oracle NetSuite Integration">
    **NetSuite Integration Pattern:**
    - SuiteScript for Request Network communication
    - Custom records for payment tracking
    - Automated journal entry creation
    - Revenue recognition automation
  </Accordion>
  
  <Accordion title="Microsoft Dynamics Integration">
    **Dynamics 365 Integration:**
    - Power Platform connectors
    - Custom API integration
    - Automated invoice processing
    - Financial reporting integration
  </Accordion>
</AccordionGroup>

## Development Best Practices

### Error Handling Strategies

<CodeGroup>
```javascript Retry Pattern
class RequestNetworkClient {
  async createRequestWithRetry(requestData, maxRetries = 3) {
    let lastError;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await requestNetwork.createRequest(requestData);
      } catch (error) {
        lastError = error;
        
        // Don't retry on permanent errors
        if (error.code === 'INVALID_REQUEST' || error.code === 'UNAUTHORIZED') {
          throw error;
        }
        
        // Exponential backoff
        const delay = Math.pow(2, attempt) * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
        
        console.log(`Request creation attempt ${attempt} failed, retrying...`);
      }
    }
    
    throw lastError;
  }
}
```

```javascript Circuit Breaker
class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.failureThreshold = threshold;
    this.timeout = timeout;
    this.failureCount = 0;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.nextAttempt = null;
  }
  
  async call(fn) {
    if (this.state === 'OPEN') {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN');
      }
      this.state = 'HALF_OPEN';
    }
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }
  
  onFailure() {
    this.failureCount++;
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
      this.nextAttempt = Date.now() + this.timeout;
    }
  }
}
```
</CodeGroup>

### Performance Optimization

<Tabs>
  <Tab title="Caching Strategies">
    **Cache Request Data:**
    ```javascript
    // Redis caching for request data
    const redis = new Redis(process.env.REDIS_URL);
    
    async function getCachedRequest(requestId) {
      const cacheKey = `request:${requestId}`;
      const cached = await redis.get(cacheKey);
      
      if (cached) {
        return JSON.parse(cached);
      }
      
      const request = await requestNetwork.getRequest(requestId);
      await redis.setex(cacheKey, 300, JSON.stringify(request)); // 5 min cache
      
      return request;
    }
    ```
  </Tab>
  
  <Tab title="Batch Processing">
    **Optimize Batch Operations:**
    ```javascript
    // Batch multiple operations
    async function processBatchPayments(payments) {
      const batchSize = 10;
      const batches = [];
      
      for (let i = 0; i < payments.length; i += batchSize) {
        batches.push(payments.slice(i, i + batchSize));
      }
      
      const results = await Promise.allSettled(
        batches.map(batch => requestNetwork.createBatchPayout({
          payouts: batch
        }))
      );
      
      return results;
    }
    ```
  </Tab>
  
  <Tab title="Connection Pooling">
    **Optimize Network Connections:**
    ```javascript
    // HTTP client with connection pooling
    const axios = require('axios');
    const { Agent } = require('https');
    
    const httpAgent = new Agent({
      keepAlive: true,
      maxSockets: 100,
      maxFreeSockets: 10,
      timeout: 60000
    });
    
    const requestNetworkClient = axios.create({
      baseURL: 'https://api.request.network',
      httpsAgent: httpAgent,
      timeout: 30000
    });
    ```
  </Tab>
</Tabs>

## What's Next?

<CardGroup cols={3}>
  <Card 
    title="📚 API Reference" 
    href="/api-reference/authentication"
    icon="book"
  >
    Detailed API endpoint documentation and examples
  </Card>
  
  <Card 
    title="🔑 Get Started" 
    href="/api-setup/getting-started"
    icon="rocket"
  >
    Set up your development environment and API keys
  </Card>
  
  <Card 
    title="💰 Choose Use Case" 
    href="/use-cases/invoicing"
    icon="use-case"
  >
    Explore specific implementation scenarios
  </Card>
</CardGroup>
